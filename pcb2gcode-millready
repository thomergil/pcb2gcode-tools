#!/usr/bin/env python3
"""
pcb2gcode-millready

This tool modifies G-code files generated by pcb2gcode
(https://github.com/pcb2gcode/pcb2gcode) to make them more suitable for CNC
milling operations. It swaps the initial Z and X/Y moves to ensure the tool
moves to position first before plunging. This reduces the risk of damaging the
drill bit and a jig.

It can also remove M6 tool change sequences.

Note: This code was mostly generated with the assistance of AI (Claude).
"""

import re
import argparse
import os
import sys
import math

# Constants
# Regex patterns for G-code commands to filter out (comment out in output)
# These are single-line commands that are unsupported by many G-code senders
FILTER_PATTERNS = [
    r"G64\b",  # Path control mode (LinuxCNC specific)
    r"G94\b",  # Feed rate mode (often unsupported)
]


def swap_z_and_xy_moves(infile, outfile):
    """
    Swap a Z move and subsequent XY rapid positioning move to ensure the tool
    moves to the XY starting position first, then descends to the Z height.
    This reduces the risk of damaging the drill bit or workpiece by ensuring
    lateral movement happens at safe height.

    Handles both:
    - Traditional milling patterns: G00 Z<safe_height> followed immediately by G00 X,Y
    - Drill file patterns: G0 Z<work_height> with intervening commands (G04, G1 F, M3/M5, T)
      before the first G0 X,Y positioning move

    Only the first occurrence in the file is swapped.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        bool: True if the swap was performed, False otherwise
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    swapped = False  # Flag to track if we've already done the swap

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        if swapped: # If already swapped, just append lines
            new_lines.append(lines[i])
            i += 1
            continue

        # Test for Z-safe move or Z working height move
        z_move_regex_str = r"G0[0]?\s+Z\s*[0-9.]+"
        match_z = re.match(z_move_regex_str, current_line_stripped)

        if match_z:
            # Potential Z move found. Look for the first XY positioning move,
            # allowing for multiple intervening commands (not just comments)
            j = i + 1
            found_xy_move_line_content = None
            found_xy_move_line_index = -1
            intervening_lines = []
            xy_found = False

            while j < len(lines) and not xy_found:
                next_line_stripped = lines[j].strip()

                # Skip empty lines and comments
                if not next_line_stripped or next_line_stripped.startswith("("):
                    intervening_lines.append(lines[j])
                    j += 1
                    continue

                # Check if this is an XY positioning move
                xy_move_regex_str = r"G0[0]?\s+X.*Y"
                match_xy = re.match(xy_move_regex_str, next_line_stripped)

                if match_xy:
                    found_xy_move_line_content = lines[j]
                    found_xy_move_line_index = j
                    xy_found = True
                else:
                    # Check if this is a command that could be between Z and XY moves
                    # Common commands in drill files: G04 (dwell), G1 F (feed rate), M3/M5 (spindle)
                    intervening_command_regex = r"(G04|G1\s+F|M[35]|T\d+)"
                    if re.match(intervening_command_regex, next_line_stripped):
                        intervening_lines.append(lines[j])
                        j += 1
                        continue
                    else:
                        # Found a command that's not expected between Z and XY moves
                        # Stop looking for XY move after this Z move
                        break

            if found_xy_move_line_content:
                # Pattern found! Swap XY move before Z move, keep intervening commands after Z move
                new_lines.append(found_xy_move_line_content) # XY move first
                new_lines.append(lines[i])                   # Z move second
                new_lines.extend(intervening_lines)          # Intervening commands after Z move

                swapped = True
                i = found_xy_move_line_index + 1 # Advance i past the processed XY line
            else:
                # Z-move was found, but no suitable XY-move. Add current line and continue.
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a Z-move, or already swapped. Add current line and continue.
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if swapped:
        print(
            f"Initial Z/X,Y rapid moves swapped (including drill file pattern). Modified G-code saved to {outfile}"
        )
    else:
        print(f"No Z/X,Y rapid move pattern found to swap. G-code copied to {outfile}")

    return swapped


def remove_m6_sequences(infile, outfile):
    """
    Remove M6 tool change sequences and filter out unsupported G-code commands.

    This function:
    1. Comments out any lines matching patterns in FILTER_PATTERNS constant
    2. Removes M6 tool change sequences (from retract to tool change height
       through the lines before spindle restart M3)

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        tuple: (sequences_removed, commands_filtered)
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    sequences_removed = 0
    commands_filtered = 0

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        # Check if line matches any filter pattern
        should_filter = False
        for pattern in FILTER_PATTERNS:
            if re.match(pattern, current_line_stripped):
                should_filter = True
                break

        if should_filter:
            # Comment out the line
            new_lines.append(f"( {current_line_stripped} )\n")
            commands_filtered += 1
            i += 1
            continue

        # Look for retract to tool change height (G00 Z followed by numbers)
        # This typically appears as "G00 Z35.00000 (Retract to tool change height)"
        retract_regex = r"G0[0]?\s+Z\s*[0-9.]+.*tool\s+change\s+height"
        match_retract = re.search(retract_regex, current_line_stripped, re.IGNORECASE)

        if match_retract:
            # Found start of tool change sequence, skip lines until we find M3 (spindle on)
            j = i + 1
            found_spindle_restart = False

            while j < len(lines):
                next_line_stripped = lines[j].strip()

                # Look for M3 (spindle on clockwise)
                if re.match(r"M3\b", next_line_stripped):
                    found_spindle_restart = True
                    break

                j += 1

            if found_spindle_restart:
                # Skip all lines from retract through the line before M3
                sequences_removed += 1
                i = j  # Continue from the M3 line
            else:
                # No M3 found, keep the current line
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a tool change retract line, keep it
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if sequences_removed > 0 or commands_filtered > 0:
        msg_parts = []
        if sequences_removed > 0:
            msg_parts.append(f"removed {sequences_removed} M6 tool change sequence(s)")
        if commands_filtered > 0:
            msg_parts.append(f"commented out {commands_filtered} unsupported command(s)")
        print(f"{msg_parts[0].capitalize() if msg_parts else 'Modified'}, {', '.join(msg_parts[1:])}. G-code saved to {outfile}")
    else:
        print(f"No M6 tool change sequences or unsupported commands found. G-code copied to {outfile}")

    return (sequences_removed, commands_filtered)


def main():
    """
    Main function to process command line arguments and execute G-code modifications.
    """
    parser = argparse.ArgumentParser(
        description="""
        PCB2GCode G-code Post-Processor

        Modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
        to make them more suitable for CNC milling operations. It can swap Z/XY moves
        for safer operation and remove M6 tool change sequences.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument("infile", help="Input G-code file generated by pcb2gcode")
    parser.add_argument("outfile", help="Output G-code file")
    parser.add_argument("--remove-m6", action="store_true",
                       help="Remove M6 tool change sequences")
    parser.add_argument("--version", action="version", version="%(prog)s 1.0.0")

    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.infile):
        print(f"Error: Input file '{args.infile}' not found.", file=sys.stderr)
        sys.exit(1)

    # Check if output directory exists
    outdir = os.path.dirname(args.outfile)
    if outdir and not os.path.exists(outdir):
        print(f"Creating output directory: {outdir}")
        os.makedirs(outdir, exist_ok=True)

    # Process the file
    try:
        current_file = args.infile

        if args.remove_m6:
            print("Processing: Removing M6 tool change sequences...")
            remove_m6_sequences(current_file, args.outfile)
            current_file = args.outfile

        print("Processing: Swapping Z and X,Y moves...")
        swap_z_and_xy_moves(current_file, args.outfile)

        print(f"Processing complete. Final G-code saved to {args.outfile}")

    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
