#!/usr/bin/env python3
"""
pcb2gcode-millready

This tool modifies G-code files generated by pcb2gcode
(https://github.com/pcb2gcode/pcb2gcode) to make them more suitable for CNC
milling operations. It swaps the initial Z and X/Y moves to ensure the tool
moves to position first before plunging. This reduces the risk of damaging the
drill bit and a jig.

It can also remove M6 tool change sequences.
"""

import re
import argparse
import os
import sys
import math

# Constants
# Regex patterns for G-code commands to filter out (comment out in output)
# These are single-line commands that are unsupported by many G-code senders
FILTER_PATTERNS = [
    r"G64\b",  # Path control mode (LinuxCNC specific)
    r"G94\b",  # Feed rate mode (often unsupported)
]

# Default minimum segment length in mm
# Segments shorter than this are considered Voronoi artifacts and removed
# Set to 0 to disable (use pcb2gcode's --min-path-length instead)
DEFAULT_MIN_SEGMENT_LENGTH = 0


def swap_z_and_xy_moves(infile, outfile):
    """
    Swap a Z move and subsequent XY rapid positioning move to ensure the tool
    moves to the XY starting position first, then descends to the Z height.
    This reduces the risk of damaging the drill bit or workpiece by ensuring
    lateral movement happens at safe height.

    Handles both:
    - Traditional milling patterns: G00 Z<safe_height> followed immediately by G00 X,Y
    - Drill file patterns: G0 Z<work_height> with intervening commands (G04, G1 F, M3/M5, T)
      before the first G0 X,Y positioning move

    Only the first occurrence in the file is swapped.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        bool: True if the swap was performed, False otherwise
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    swapped = False  # Flag to track if we've already done the swap

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        if swapped: # If already swapped, just append lines
            new_lines.append(lines[i])
            i += 1
            continue

        # Test for Z-safe move or Z working height move
        z_move_regex_str = r"G0[0]?\s+Z\s*[0-9.]+"
        match_z = re.match(z_move_regex_str, current_line_stripped)

        if match_z:
            # Potential Z move found. Look for the first XY positioning move,
            # allowing for multiple intervening commands (not just comments)
            j = i + 1
            found_xy_move_line_content = None
            found_xy_move_line_index = -1
            intervening_lines = []
            xy_found = False

            while j < len(lines) and not xy_found:
                next_line_stripped = lines[j].strip()

                # Skip empty lines and comments
                if not next_line_stripped or next_line_stripped.startswith("("):
                    intervening_lines.append(lines[j])
                    j += 1
                    continue

                # Check if this is an XY positioning move
                xy_move_regex_str = r"G0[0]?\s+X.*Y"
                match_xy = re.match(xy_move_regex_str, next_line_stripped)

                if match_xy:
                    found_xy_move_line_content = lines[j]
                    found_xy_move_line_index = j
                    xy_found = True
                else:
                    # Check if this is a command that could be between Z and XY moves
                    # Common commands in drill files: G04 (dwell), G1 F (feed rate), M3/M5 (spindle)
                    intervening_command_regex = r"(G04|G1\s+F|M[35]|T\d+)"
                    if re.match(intervening_command_regex, next_line_stripped):
                        intervening_lines.append(lines[j])
                        j += 1
                        continue
                    else:
                        # Found a command that's not expected between Z and XY moves
                        # Stop looking for XY move after this Z move
                        break

            if found_xy_move_line_content:
                # Pattern found! Swap XY move before Z move, keep intervening commands after Z move
                new_lines.append(found_xy_move_line_content) # XY move first
                new_lines.append(lines[i])                   # Z move second
                new_lines.extend(intervening_lines)          # Intervening commands after Z move

                swapped = True
                i = found_xy_move_line_index + 1 # Advance i past the processed XY line
            else:
                # Z-move was found, but no suitable XY-move. Add current line and continue.
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a Z-move, or already swapped. Add current line and continue.
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if swapped:
        print(
            f"Initial Z/X,Y rapid moves swapped (including drill file pattern). Modified G-code saved to {outfile}"
        )
    else:
        print(f"No Z/X,Y rapid move pattern found to swap. G-code copied to {outfile}")

    return swapped


def filter_unsupported_commands(infile, outfile):
    """
    Filter out unsupported G-code commands by commenting them out.

    Comments out any lines matching patterns in FILTER_PATTERNS constant.
    Handles lines that already contain G-code comments (parentheses) by
    converting inner parentheses to square brackets to avoid invalid
    nested parentheses.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        int: Number of commands filtered
    """
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    commands_filtered = 0

    for line in lines:
        line_stripped = line.strip()

        # Check if line matches any filter pattern
        should_filter = False
        for pattern in FILTER_PATTERNS:
            if re.match(pattern, line_stripped):
                should_filter = True
                break

        if should_filter:
            # Comment out the line, converting any existing parens to brackets
            # to avoid invalid nested parentheses in G-code
            commented_content = line_stripped.replace("(", "[").replace(")", "]")
            new_lines.append(f"( {commented_content} )\n")
            commands_filtered += 1
        else:
            new_lines.append(line)

    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if commands_filtered > 0:
        print(f"Commented out {commands_filtered} unsupported command(s). G-code saved to {outfile}")
    else:
        print(f"No unsupported commands found. G-code copied to {outfile}")

    return commands_filtered


def remove_m6_sequences(infile, outfile):
    """
    Remove M6 tool change sequences.

    Removes M6 tool change sequences (from retract to tool change height
    through the lines before spindle restart M3).

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        int: Number of sequences removed
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    sequences_removed = 0

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        # Look for retract to tool change height (G00 Z followed by numbers)
        # This typically appears as "G00 Z35.00000 (Retract to tool change height)"
        retract_regex = r"G0[0]?\s+Z\s*[0-9.]+.*tool\s+change\s+height"
        match_retract = re.search(retract_regex, current_line_stripped, re.IGNORECASE)

        if match_retract:
            # Found start of tool change sequence, skip lines until we find M3 (spindle on)
            j = i + 1
            found_spindle_restart = False

            while j < len(lines):
                next_line_stripped = lines[j].strip()

                # Look for M3 (spindle on clockwise)
                if re.match(r"M3\b", next_line_stripped):
                    found_spindle_restart = True
                    break

                j += 1

            if found_spindle_restart:
                # Skip all lines from retract through the line before M3
                sequences_removed += 1
                i = j  # Continue from the M3 line
            else:
                # No M3 found, keep the current line
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a tool change retract line, keep it
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if sequences_removed > 0:
        print(f"Removed {sequences_removed} M6 tool change sequence(s). G-code saved to {outfile}")
    else:
        print(f"No M6 tool change sequences found. G-code copied to {outfile}")

    return sequences_removed


def remove_tiny_segments(infile, outfile, min_length=DEFAULT_MIN_SEGMENT_LENGTH):
    """
    Remove tiny milling segments that are artifacts from Voronoi region generation.

    These segments consist of:
    - A rapid move to position (G00 X Y)
    - A plunge to cutting depth (G01 Z-depth)
    - Very short cutting moves (total distance < min_length)
    - A retract (G00 Z safe_height)

    Such segments create tiny dots that serve no useful purpose and waste time.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file
        min_length (float): Minimum segment length in mm (default 0.1)

    Returns:
        int: Number of tiny segments removed
    """
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    segments_removed = 0

    # Regex patterns
    rapid_xy_pattern = re.compile(r"G0[0]?\s+X([0-9.-]+)\s*Y([0-9.-]+)")
    plunge_pattern = re.compile(r"G01\s+Z\s*(-[0-9.]+)")
    cut_xy_pattern = re.compile(r"G01\s+X([0-9.-]+)\s*Y([0-9.-]+)")
    retract_pattern = re.compile(r"G0[0]?\s+Z\s*([0-9.]+)")

    while i < len(lines):
        line = lines[i]
        line_stripped = line.strip()

        # Look for rapid move to begin a segment
        rapid_match = rapid_xy_pattern.match(line_stripped)
        if rapid_match and "rapid move to begin" in line_stripped:
            start_x = float(rapid_match.group(1))
            start_y = float(rapid_match.group(2))

            # Collect the potential segment
            segment_lines = [line]
            j = i + 1
            in_cut = False
            cut_moves = []
            segment_end = -1

            while j < len(lines):
                next_line = lines[j]
                next_stripped = next_line.strip()
                segment_lines.append(next_line)

                # Check for plunge
                if plunge_pattern.match(next_stripped):
                    in_cut = True
                    j += 1
                    continue

                # Check for cutting moves
                if in_cut:
                    cut_match = cut_xy_pattern.match(next_stripped)
                    if cut_match:
                        cut_moves.append((float(cut_match.group(1)), float(cut_match.group(2))))
                        j += 1
                        continue

                # Check for retract (end of segment)
                retract_match = retract_pattern.match(next_stripped)
                if retract_match and float(retract_match.group(1)) > 0:
                    segment_end = j
                    break

                # Other lines (comments, dwell, feedrate) - continue collecting
                j += 1
                if j - i > 20:  # Safety limit
                    break

            if segment_end > 0 and len(cut_moves) > 0:
                # Calculate total segment length
                total_length = 0.0
                prev_x, prev_y = start_x, start_y
                for x, y in cut_moves:
                    dx = x - prev_x
                    dy = y - prev_y
                    total_length += math.sqrt(dx * dx + dy * dy)
                    prev_x, prev_y = x, y

                if total_length < min_length:
                    # Skip this segment entirely
                    segments_removed += 1
                    i = segment_end + 1
                    continue

            # Not a tiny segment, keep it
            new_lines.append(line)
            i += 1
        else:
            new_lines.append(line)
            i += 1

    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if segments_removed > 0:
        print(f"Removed {segments_removed} tiny segment(s) shorter than {min_length}mm. G-code saved to {outfile}")
    else:
        print(f"No tiny segments found. G-code copied to {outfile}")

    return segments_removed


def main():
    """
    Main function to process command line arguments and execute G-code modifications.
    """
    parser = argparse.ArgumentParser(
        description="""
        PCB2GCode G-code Post-Processor

        Modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
        to make them more suitable for CNC milling operations. It can swap Z/XY moves
        for safer operation and remove M6 tool change sequences.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument("infile", help="Input G-code file generated by pcb2gcode")
    parser.add_argument("outfile", help="Output G-code file")
    parser.add_argument("--remove-m6", action="store_true",
                       help="Remove M6 tool change sequences")
    parser.add_argument("--min-segment-length", type=float, default=DEFAULT_MIN_SEGMENT_LENGTH,
                       metavar="MM",
                       help=f"Remove milling segments shorter than MM millimeters (default: {DEFAULT_MIN_SEGMENT_LENGTH}). "
                            "These are typically Voronoi artifacts that create useless tiny dots. "
                            "Set to 0 to disable.")

    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.infile):
        print(f"Error: Input file '{args.infile}' not found.", file=sys.stderr)
        sys.exit(1)

    # Check if output directory exists
    outdir = os.path.dirname(args.outfile)
    if outdir and not os.path.exists(outdir):
        print(f"Creating output directory: {outdir}")
        os.makedirs(outdir, exist_ok=True)

    # Process the file
    try:
        current_file = args.infile

        print("Processing: Filtering unsupported commands...")
        filter_unsupported_commands(current_file, args.outfile)
        current_file = args.outfile

        if args.remove_m6:
            print("Processing: Removing M6 tool change sequences...")
            remove_m6_sequences(current_file, args.outfile)

        if args.min_segment_length > 0:
            print(f"Processing: Removing tiny segments (<{args.min_segment_length}mm)...")
            remove_tiny_segments(current_file, args.outfile, args.min_segment_length)

        print("Processing: Swapping Z and X,Y moves...")
        swap_z_and_xy_moves(current_file, args.outfile)

        print(f"Processing complete. Final G-code saved to {args.outfile}")

    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
